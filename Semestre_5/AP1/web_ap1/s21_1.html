<!DOCTYPE html>
<html lang="fr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Algorithmique et Programmation 1</title>
    <link rel="stylesheet" href="./ap1.css">
    <link rel="stylesheet" href="./atom-one-dark.min.css">
    <link rel="stylesheet" href="./atom-one-light.min.css">
    <script src="theme-switcher.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
</head>

<body>
<header>
<a id="theme-switcher" href="#dark" aria-label="Switch to Light Mode" class="contrast">
    <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 19a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z" stroke-width="0" fill="currentColor"></path><path d="M18.313 16.91l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.218 -1.567l.102 .07z" stroke-width="0" fill="currentColor"></path><path d="M7.007 16.993a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z" stroke-width="0" fill="currentColor"></path><path d="M4 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z" stroke-width="0" fill="currentColor"></path><path d="M21 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z" stroke-width="0" fill="currentColor"></path><path d="M6.213 4.81l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.217 -1.567l.102 .07z" stroke-width="0" fill="currentColor"></path><path d="M19.107 4.893a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z" stroke-width="0" fill="currentColor"></path><path d="M12 2a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z" stroke-width="0" fill="currentColor"></path><path d="M12 7a5 5 0 1 1 -4.995 5.217l-.005 -.217l.005 -.217a5 5 0 0 1 4.995 -4.783z" stroke-width="0" fill="currentColor"></path></svg>
</a>
<h1><a href="index.html">Algo-Prog 1</a> : <a href="index.html#Chap4">Chapitre 4</a> : <a href="index.html#Chap4Seance21">Séance 21</a> : <a href="s21_1.html">Introduction au langage C</a></h1>
</header>
<main>
<div style="font-size: x-large;">
	&check; Correction : <a href="premier_prog.c">premier_prog.c</a> <a href="calculs.c">calculs.c</a> <a href="etat_civil.c">etat_civil.c</a> <a href="tris_tabs.c">tris_tabs.c</a>
</div>
<h2 id="énoncé">Énoncé</h2>
<p>On va découvrir dans ces dernières séances le langage C, le
précurseur du langage Go. Plus précisément, on va utiliser le dialecte
C99 qui est une version plus moderne que le C initial (dit C ANSI). Le C
a été inventé en 1972 par <a
href="https://fr.wikipedia.org/wiki/Dennis_Ritchie">Dennis
Ritchie</a>,</p>
<figure>
<img src="s21_1_dennis.jpg" title="Encore un barbu" alt="Dennis" />
<figcaption aria-hidden="true">Dennis</figcaption>
</figure>
<p>par extension du langage B inventé lui-même par <a
href="https://fr.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a>
(l’inventeur de Go donc) : les deux avaient besoin du C pour développer
le premier système Unix.</p>
<figure>
<img src="s21_1_ken_et_dennis.jpg"
title="On voit que Ken est le Maître-Jedi car la barbe est plus longue"
alt="Ken et Dennis" />
<figcaption aria-hidden="true">Ken et Dennis</figcaption>
</figure>
<p>Vous étudierez le C de façon plus complète au deuxième semestre : on
se contentera ici d’une courte introduction. Si vous avez envie d’en
savoir déjà plus, vous pouvez lire le <a href="poly_c.pdf">polycopié de
Bernard Cassagne</a> qui présente le C ANSI original, mais ce n’est pas
indispensable dans le cadre du cours d’AP1.</p>
<p>Le C est un langage très similaire à Go (ou plutôt l’inverse), mais
spécifié 40 plus tôt : on aura donc parfois l’impression de remonter le
temps en faisant du C, qui paraîtra un peu archaïque par rapport à
Go.</p>
<p>Il est néanmoins indispensable de connaître le C, qui reste encore
aujourd’hui un des langages les plus utilisés au monde, notamment dans
le cadre du développement système. De façon plus prosaïque, vous aurez
besoin de connaître les bases de ce langage pour suivre certains cours
du 2e semestre, notamment ILM.</p>
<p>Néanmoins, on ne va pas apprendre tout un nouveau langage en quelques
séances : on se limitera à traduire des programmes Go sur lesquels on a
déjà travaillé pour apprendre les différences syntaxiques entre les deux
langages, et on ajoutera quelques concepts comme l’arithmétique des
pointeurs et la gestion mémoire manuelle qui n’existent pas en Go.</p>
<h3 id="premier-programme-en-c">Premier programme en C</h3>
<p>On vous recommande de stocker tous vos programmes en C dans un
répertoire commun, dans lequel vous pouvez commencer par télécharger ce
fichier <a href="Makefile">Makefile</a>.</p>
<p><strong>Attention</strong> : faites bien bouton-droit puis «
enregistrer sous », et pas copier-coller du contenu, car les tabulations
font partie du format et certains navigateurs les transforment en
espaces sans le dire !</p>
<p><strong>Attention</strong> : vérifiez bien que le navigateur n’a pas
renommé le fichier en <code>Makefile.txt</code> sans vous le dire, sinon
ça ne marchera pas, car le fichier <strong>doit</strong> s’appeller
<code>Makefile</code>. Si c’est le cas, il suffit de taper
<code>mv Makefile.txt Makefile</code> dans le terminal pour lui donner
le bon nom.</p>
<p>Un <code>Makefile</code> est un fichier qui décrit comment compiler
des programmes (quelque-soit le langage d’ailleurs), et qui est
particulièrement utilisé pour compiler du C. En effet, la chaîne de
compilation C est nettement plus complexe que celle de Go, mais vous
aurez l’occasion de comprendre tout cela au 2e semestre.</p>
<p>Ensuite, créer un fichier <code>premier_prog.c</code> dans lequel
vous recopierez le code suivant :</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;Coucou !</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>La première ligne commençant par <code>#include</code> indique au
compilateur que l’on va utiliser le module prédéfini <code>stdio</code>,
qui contient notamment des fonctions d’affichage : c’est assez similaire
au <code>import "fmt"</code> que l’on utilisait en Go.</p>
<p>Ensuite, on définit une fonction <code>main</code> : comme en Go, il
s’agit du point d’entrée du programme. On note cependant que la syntaxe
est un peu différente :</p>
<ul>
<li>le mot-clé <code>func</code> n’existe pas en C, le compilateur
reconnait les fonctions sans ce mot-clé ;</li>
<li>le type <code>int</code> désigne un entier signé (exactement comme
en Go), mais le fait qu’il soit écrit avant le nom de la fonction
signifie qu’il s’agit du type de la valeur renvoyée par cette fonction :
c’est donc l’inverse de la syntaxe Go où on précisait le type après le
nom de la fonction ;</li>
<li>le <code>void</code> entre les parenthèses indique que cette
fonction ne prend pas de paramètre (ou dans le cas de <code>main</code>,
qu’ici on ne s’en sert pas) : mais si on ne met rien comme en Go, ça
marchera très bien aussi ;</li>
<li>la fonction <code>main</code> renvoie en fait toujours un entier
signé qui représente un code d’erreur renvoyé au système à la fin de son
exécution : par convention, on renvoie 0 quand tout s’est bien passé et
autre-chose en cas d’erreur ; lorsqu’on n’écrit pas de
<code>return</code> explicite comme c’est le cas dans notre exemple, le
compilateur ajoute tout seul un <code>return 0</code>.</li>
</ul>
<p>Dans cette fonction, on utilise la fonction <code>printf</code> qui
existe aussi en Go : elle fonctionne d’ailleurs quasiment de la même
façon.</p>
<p>L’avantage du C est que toute la documentation est fournie par défaut
avec Linux : il suffit de taper <code>man 3 printf</code> dans un
terminal pour obtenir la documentation, et cela sera vrai pour toutes
les fonctions C que l’on utilisera dans nos TP !
<strong>Attention</strong> : n’oubliez pas le <code>3</code> sinon cela
vous donnera l’aide d’une autre commande qui s’appelle aussi
<code>printf</code>, mais n’a rien à voir.</p>
<p><strong>Attention</strong> : chaque ligne de C <strong>doit</strong>
se terminer par un point-virgule ! Le point-virgule est le séparateur
entre les instructions, et il est d’ailleurs possible (mais pas
recommandé pour des questions de lisibilité) de mettre plusieurs
instructions sur la même ligne si on les sépare par des
points-virgules.</p>
<p>Une fois que vous avez recopié et sauvegardé ce bout de code, tapez
simplement la commande <code>make</code> dans votre terminal : si tout
se passe bien, le binaire <code>premier_prog</code> est généré, et vous
pouvez l’exécuter en tapant <code>./premier_prog</code>. Vous pouvez
nettoyer votre répertoire en tapant <code>make clean</code> qui va
effacer tous les fichiers binaires.</p>
<h3 id="types-de-données-et-fonctions">Types de données et
fonctions</h3>
<p>Créez maintenant un fichier <code>calculs.c</code> dans lequel vous
commencerez par recopier le code suivant :</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> fact<span class="op">(</span><span class="dt">unsigned</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">unsigned</span> res<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>res <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> n <span class="op">&gt;</span> <span class="dv">1</span><span class="op">;</span> n<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        res <span class="op">*=</span> n<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> test_fact<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">unsigned</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">6</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%u</span><span class="st">! = </span><span class="sc">%u\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> fact<span class="op">(</span>i<span class="op">));</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    puts<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    test_fact<span class="op">();</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>On va utiliser le module <code>math</code> un peu plus tard dans cet
exercice, donc on peut l’inclure tout de suite.</p>
<p><strong>Attention</strong> : en C, l’ordre de déclaration des
fonctions (ainsi que des variables globales) est important : on doit
implanter <code>fact</code> avant <code>test_fact</code> qui l’utilise
et qui elle-même doit être implantée avant <code>main</code> qui
l’appelle.</p>
<p>On voit que la fonction <code>fact</code> prend un entier non signé
<code>n</code> en paramètre et renvoie un résultat lui-même entier non
signé : le type <code>unsigned</code> est le même qu’en Go.</p>
<p>Dans cette fonction, on déclare une variable <code>res</code> de type
entier non signé : on remarque que le mot-clé <code>var</code> n’existe
pas en C, le compilateur sait reconnaitre les déclarations de variables.
On note aussi qu’en C, les types sont avant les noms des variables,
paramètres des fonctions, etc.</p>
<p>Ensuite on utilise une boucle <code>for</code> qui ressemble
franchement à celle de Go : une différence importante est que
<strong>les parenthèses sont obligatoires</strong>.</p>
<p>La fonction <code>test_fact</code> ne renvoie rien (c’est une
procédure) : en C, le type <code>void</code> sert à préciser qu’on ne
renvoie rien, et il est obligatoire de l’utiliser dans ce cas (on ne
peut pas juste ne pas écrire de type de retour).</p>
<p>On note au passage qu’en C, la convention d’écriture est le <a
href="https://fr.wikipedia.org/wiki/Snake_case"><em>snake
case</em></a>.</p>
<p>On voit que les directives de formatage pour <code>printf</code> sont
globalement les mêmes qu’en Go : ici <code>%u</code> veut dire entier
non signé.</p>
<p>Enfin, on utilise la fonction <code>puts</code> qui est une version
simplifiée de <code>printf</code> : elle ne prend qu’une chaîne simple
en paramètre (sans directives de formatage) et ajoute automatiquement un
retour à la ligne à la fin (ici on s’en sert donc pour sauter une
ligne).</p>
<p>Compilez votre programme en tapant <code>make</code> : vous noterez
que le <code>Makefile</code> fourni compile automatiquement tous les
programmes <code>.c</code> qu’il trouve dans le répertoire. Si vous
souhaitez ne compiler que le programme <code>calculs.c</code>, il suffit
de taper <code>make calculs</code> (il faut bien indiquer le nom du
binaire de destination et pas le programme lui-même).</p>
<p>Ajoutez maintenant le bout de code suivant à votre programme :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> racine<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&lt;</span> <span class="fl">0.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>NAN<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> res <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">unsigned</span> nbr_iter <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> nbr_iter <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> nbr_iter<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        res <span class="op">=</span> <span class="op">(</span>res <span class="op">+</span> <span class="op">(</span>x <span class="op">/</span> res<span class="op">))</span> <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> test_racine<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">double</span> val <span class="op">=</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">;</span> val <span class="op">&lt;</span> <span class="fl">10.0</span><span class="op">;</span> val <span class="op">+=</span> <span class="fl">1.0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;racine(</span><span class="sc">%g</span><span class="st">) = </span><span class="sc">%g</span><span class="st"> ~ </span><span class="sc">%g\n</span><span class="st">&quot;</span><span class="op">,</span> val<span class="op">,</span> racine<span class="op">(</span>val<span class="op">),</span> sqrt<span class="op">(</span>val<span class="op">));</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Le type <code>double</code> désigne des réels flottants sur 64 bits :
il est équivalent au type <code>float64</code> de Go. <code>NAN</code>
est une constante définie dans le module <code>math</code> et qui
signifie « pas un nombre réel ».</p>
<p>De même, la fonction <code>sqrt</code> est dans le module
<code>math</code> et calcule la racine carrée de son paramètre : on s’en
sert de référence pour vérifier notre algorithme.</p>
<p>La directive <code>%g</code> de <code>printf</code> sert à afficher
un flottant : la directive <code>%v</code> bien pratique en Go, qui
choisissait tout seul la bonne directive en fonction du type n’existe
malheureusement pas en C.</p>
<p>Ajouter un appel à <code>test_racine</code> dans la fonction
<code>main</code>, recompilez et exécutez le programme pour vérifier
qu’il fonctionne comme attendu.</p>
<p>Ajouter maintenant à votre programme une fonction
<code>int pgcd(unsigned a, unsigned b)</code> qui calcule le PGCD de ses
paramètres en utilisant l’algorithme par soustractions successives : on
rappelle que l’on avait fait cet exercice en Go lors du TP « Calculs »
de la séance 5 : vous pouvez bien sûr reprendre le code pour vous en
inspirer !</p>
<p>On note qu’en C, les parenthèses sont aussi obligatoires autour de la
condition d’un <code>if</code>, et qu’il existe un type de boucle
inconnu en Go : <code>while (condition) {...}</code> est en fait
exactement équivalent à <code>for condition {...}</code> en Go.</p>
<p>Cette fonction doit renvoyer un entier <strong>signé</strong> car on
pose par convention qu’elle renverra -1 ssi au moins un de ces deux
paramètres est nul. En effet, le type <code>error</code> que l’on
utilisait souvent en Go n’existe pas en C, et la convention est de
renvoyer une valeur entière non significative en cas d’erreur.</p>
<p>Notez qu’en C, il n’est pas nécessaire de convertir explicitement un
entier non signé en entier signé (et vice-versa) : le compilateur est
très relaxé concernant les types de données et fait des conversions
implicites quand nécessaire.</p>
<p>Ajoutez ensuite une fonction <code>test_pgcd</code> qui doit au moins
effectuer les appels suivants pour tester votre fonction
<code>pgcd</code> et afficher le résultat ou un message d’erreur
approprié :</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>pgcd<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>pgcd<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>pgcd<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>pgcd<span class="op">(</span><span class="dv">15</span><span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>pgcd<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">15</span><span class="op">);</span></span></code></pre></div>
<p>Ajouter un appel à cette fonction de test dans votre fonction
<code>main</code>, recompilez et exécutez le programme pour vérifier que
tout se passe comme attendu.</p>
<h3 id="structures">Structures</h3>
<p>Le C propose des structures (mot-clé <code>struct</code>) tout à fait
similaires à celles de Go. On va s’en servir en reprenant l’exercice «
Structures » de la séance 2.</p>
<p>Créer un fichier <code>etat-civil.c</code> et copiez-collez y le code
ci-dessous :</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdint.h&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">char</span> <span class="op">*</span>chaine_t<span class="op">;</span></span></code></pre></div>
<p>On va utiliser le module <code>stdint</code> qui contient les entiers
de taille fixe (<code>int8_t</code>, <code>uint16_</code>, etc.) qu’on
avait vu en Go, ainsi que le module <code>stdbool</code> qui définit le
type <code>bool</code> et les constantes <code>true</code> et
<code>false</code> (qui n’existaient pas dans la version initiale du
langage !).</p>
<p>La ligne <code>typedef char *chaine_t;</code> permet de définir un
nouveau type : ici, on définit le type <code>chaine_t</code> (une chaîne
de caractères) comme étant simplement un pointeur vers un caractère (le
premier de la chaîne). En effet, en C il n’existe pas de type
<code>string</code> spécifique comme en Go : une chaîne de caractères
est simplement un tableau de caractères dont la dernière case contient
un caractère spécial (<code>'\0'</code>) qui marque la fin de la
chaîne.</p>
<p>On aurait pu aussi définir le type chaîne comme suit (ne le faites
pas, c’est un exemple !) :</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TAILLE_MAX_CHAINE </span><span class="dv">33</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">char</span> chaine_t<span class="op">[</span>TAILLE_MAX_CHAINE<span class="op">];</span></span></code></pre></div>
<p>La ligne (macro) commençant par <code>#define</code> précise
simplement au compilateur que toutes les occurrences de
<code>TAILLE_MAX_CHAINE</code> doivent être remplacée par 33 : il s’agit
d’un remplacement textuel simple (pensez à un copier+remplacer dans un
éditeur de texte) et il ne faut donc <strong>pas mettre de
point-virgule</strong> à la fin de cette ligne, sinon il sera inclus
dans le texte remplacé !</p>
<p>Notez bien que définir une chaîne comme un pointeur ou un tableau
n’est pas équivalent :</p>
<ul>
<li>dans le cas d’un pointeur, aucun espace mémoire n’est alloué : il
faudra le faire avant de stocker des caractères, ou comme dans le cas de
cet exercice, pointer sur une chaîne allouée statiquement ;</li>
<li>dans le cas d’un tableau, l’espace mémoire (ici 33 octets, donc 32
caractères significatifs + le <code>'\0'</code> final) est alloué à la
déclaration d’une variable et les variables de ce type seront des
constantes (plus précisément, on pourra changer leur contenu, mais pas
l’adresse de la variable elle-même) : il faudra dans ce cas-là utiliser
des fonctions particulières comme <code>strcpy</code>,
<code>strcat</code>, etc. pour les manipuler.</li>
</ul>
<p>Si cette remarque vous parait obscure, pas d’inquiétude : tout cela
vous sera expliqué précisément au 2e semestre.</p>
<p>Ajouter ensuite à votre programme le code suivant :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">enum</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    JANVIER <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> FEVRIER<span class="op">,</span> MARS<span class="op">,</span> AVRIL<span class="op">,</span> MAI<span class="op">,</span> JUIN<span class="op">,</span> JUILLET<span class="op">,</span> AOUT<span class="op">,</span> SEPTEMBRE<span class="op">,</span> OCTOBRE<span class="op">,</span> NOVEMBRE<span class="op">,</span> DECEMBRE</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> mois_t<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> jour<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    mois_t mois<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> annee<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> date_t<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    chaine_t nomPrenom<span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    date_t naissance<span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> taille<span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> motard<span class="op">;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> infos_t<span class="op">;</span></span></code></pre></div>
<p>On voit qu’il est possible de définir beaucoup de constantes d’un
coup en C, en utilisant le mot clé <code>enum</code> (similaire aux
mots-clés <code>const</code> et <code>iota</code> en Go). Par défaut, la
première constante vaudra 0 et les suivantes iront de 1 en 1 : ici, on a
précisé que <code>JANVIER</code> vaut 1, donc <code>FEVRIER</code> vaut
2, et ainsi de suite. Au passage, en C il est habituel d’écrire les noms
des constantes complètement en majuscules, mais ce n’est qu’une
convention.</p>
<p>On note au passage qu’il est traditionnel de terminer les noms des
types par <code>_t</code> en C : c’est une convention. C’est d’ailleurs
pour cela que le type <code>uint8</code> de Go s’appelle
<code>uint8_t</code> en C par exemple.</p>
<p>Les structures sont aussi utiles pour palier une limitation du C :
<strong>il n’est pas possible en C d’écrire une fonction qui renvoie
plusieurs valeurs</strong> !</p>
<p>Ajouter à votre programme le code suivant :</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> entiere<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fract<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> resultat_modf_t<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>resultat_modf_t ma_modf<span class="op">(</span><span class="dt">double</span> val<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    resultat_modf_t res<span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    res<span class="op">.</span>entiere <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span>val<span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    res<span class="op">.</span>fract <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)((</span>val <span class="op">-</span> res<span class="op">.</span>entiere<span class="op">)</span> <span class="op">*</span> <span class="dv">100</span><span class="op">);</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>On définit un type <code>resultat_modf_t</code> qui nous sert à
renvoyer deux entiers signés en résultat de la fonction
<code>ma_modf</code> (qui existe déjà en C sous le nom de
<code>modf</code> : tapez <code>man 3 modf</code> dans un terminal pour
avoir la documentation).</p>
<p>On voit au passage que la syntaxe pour une conversion de type
explicite est un peu différente : <code>int(val)</code> en Go devient
<code>(int)val</code> en C.</p>
<p>Avec tous ces types, on peut écrire notre fonction <code>main</code>
comme suit :</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    infos_t eddy <span class="op">=</span> <span class="op">{</span><span class="st">&quot;Édouard Bracame&quot;</span><span class="op">,</span> <span class="op">{</span><span class="dv">15</span><span class="op">,</span> JUIN<span class="op">,</span> <span class="dv">1950</span><span class="op">},</span> <span class="fl">1.78</span><span class="op">,</span> <span class="kw">true</span><span class="op">};</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    infos_t obelix <span class="op">=</span> <span class="op">{.</span>taille <span class="op">=</span> <span class="fl">1.83</span><span class="op">,</span> <span class="op">.</span>naissance <span class="op">=</span> <span class="op">{</span><span class="dv">4</span><span class="op">,</span> SEPTEMBRE<span class="op">,</span> <span class="op">-</span><span class="dv">70</span><span class="op">},</span> <span class="op">.</span>nomPrenom <span class="op">=</span> <span class="st">&quot;Obelix&quot;</span> <span class="op">};</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    obelix<span class="op">.</span>motard <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    afficher<span class="op">(</span>eddy<span class="op">);</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    puts<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    afficher<span class="op">(</span>obelix<span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>On voit dans le cas d’Eddy qu’on peut initialiser tous les champs
d’une structure d’un coup <strong>ssi on les fournit dans
l’ordre</strong> au moment de la déclaration.</p>
<p>Mais il est aussi possible d’initialiser les champs dans le désordre
si on précise le nom du champ préfixé d’un point, comme on fait pour
Obelix. Ceux qui ne sont pas précisés lors de la déclaration auront des
valeurs <strong>aléatoires et non-prévisibles</strong> : attention,
c’est une grosse différence par rapport à Go, les variables ne sont pas
initialisées avec une valeur par défaut (nulle). Il faudra donc les
initialiser à la main plus tard si on veut s’en servir.</p>
<p>En Go, on avait appelé <code>fmt.Println</code> directement sur une
structure pour obtenir un affichage basique, mais fonctionnel. Ce n’est
pas possible en C : <code>printf</code> ne sait pas afficher une
<code>struct</code>.</p>
<p>Écrivez une fonction <code>void afficher(infos_t moi)</code> qui
affiche les champs de la structure passée en paramètre, sous le format
suivant :</p>
<pre class="text"><code>Je m&#39;appelle Édouard Bracame
Je suis né le 15/06/1950
Je mesure 1 mètre 78
Gaaaaaz !

Je m&#39;appelle Obelix
Je suis né le 04/09/-70
Je mesure 1 mètre 83
C&#39;est quoi une moto ?</code></pre>
<h3 id="tableaux">Tableaux</h3>
<p>En C, il n’existe que des tableaux statiques : les
<code>slices</code> de Go n’ont pas d’équivalent, mais on verra dans un
prochain TP comment il est facile de les implanter en C (et comment il
est facile de très mal s’en servir !).</p>
<p>Créez un fichier <code>tris_tabs.c</code> dans lequel vous pouvez
commencer par copier-coller le bout de code suivant :</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;time.h&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define VAL_SUP </span><span class="dv">10</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TAILLE_MAX </span><span class="dv">6</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> remplir<span class="op">(</span><span class="dt">int</span> tab<span class="op">[],</span> <span class="dt">unsigned</span> taille<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">unsigned</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> taille<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        tab<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> random<span class="op">()</span> <span class="op">%</span> VAL_SUP<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>On commence par inclure des modules classiques dont on va avoir
besoin, puis on définit deux constantes : rien de nouveau ici.</p>
<p>Ensuite, on définit une fonction <code>remplir</code> qui va remplir
le tableau passé en paramètre avec des entiers signés pseudo-aléatoires.
On remarque qu’encore une fois, la syntaxe pour les tableaux est un peu
l’inverse de celle de Go : au lieu d’écrire <code>tab []int</code>, on
doit écrire <code>int tab[]</code> (le chaînon manquant dans l’évolution
de cette syntaxe paraitra peut-être évident à ceux qui connaitraient
Java où on aurait écrit <code>int[] tab</code>).</p>
<p>On est obligé de passer en paramètre la taille du tableau à la
fonction <code>remplir</code> : en effet, la fonction
<code>len(tab)</code> très pratique en Go n’existe pas en C (et pour
ceux qui seraient tentés d’utiliser <code>sizeof(tab)</code>,
<strong>cela ne fait pas du tout ce que vous pensez dans le cas d’un
tableau passé en paramètre d’une fonction !</strong>).</p>
<p>Ici, on doit préciser qu’en C (comme en Go), les paramètres d’une
fonction sont passés par copie : par exemple on peut modifier librement
le paramètre <code>taille</code> dans la fonction <code>remplir</code>
sans que ça modifie la variable passée dans la fonction appelante.</p>
<p>Mais en C, il y a une exception : <strong>les tableaux sont toujours
passés par pointeur</strong> et il ne faut pas écrire
<code>int *tab[]</code> pour ça comme on aurait pu le faire en
s’inspirant de Go.</p>
<p>Cela implique que toute modification du tableau dans la fonction
<code>remplir</code> se fera bien sur le tableau passé en paramètre dans
la fonction appelante.</p>
<p>On utilise la fonction <code>random</code>
(<code>man 3 random</code>) qui renvoie un entier non signé dans
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mi>.</mi><msup><mn>.2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0..2^{31}-1]</annotation></semantics></math>
: on doit donc utiliser un modulo pour limiter les valeurs à
l’intervalle [0..VAL_SUP]. Cette fonction se base sur une graine pour
savoir où débuter dans la séquence d’entiers pseudo-aléatoires qu’elle
renvoie : si on veut que cette séquence change à chaque exécution du
programme, il faut utiliser la fonction <code>srandom</code>
(<code>man 3 srandom</code>) qui sert précisément à ça.</p>
<p>On peut donc déjà commencer à écrire notre fonction <code>main</code>
comme suit :</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    srandom<span class="op">(</span>time<span class="op">(</span>NULL<span class="op">));</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>La fonction <code>time</code> (<code>man 3 time</code>) renvoie
l’heure courante, ce qui permet de faire changer la graine à chaque
exécution, et on lui passe en paramètre la constante <code>NULL</code>
définie dans le module <code>stdio</code> et qui est l’équivalent du
<code>nil</code> qu’on connait en Go (le pointeur nul).</p>
<p>On peut ajouter à notre programme la fonction suivante qui permet
d’échanger les valeurs des paramètres passés : avez-vous bien compris
pourquoi on <strong>doit</strong> passer des pointeurs sur ces
paramètres, et ce qui se passerait si on passait directement les entiers
?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> echanger<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp <span class="op">=</span> <span class="op">*</span>a<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>a <span class="op">=</span> <span class="op">*</span>b<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>b <span class="op">=</span> tmp<span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>On fournit aussi une fonction d’affichage d’un tableau : en effet,
<code>printf</code> ne sait pas non plus afficher les tableaux…</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> afficher<span class="op">(</span><span class="dt">int</span> tab<span class="op">[],</span> <span class="dt">unsigned</span> taille<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;[ &quot;</span><span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">unsigned</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> taille<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span><span class="op">,</span> tab<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    puts<span class="op">(</span><span class="st">&quot;]&quot;</span><span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Écrivez maintenant trois fonctions de tri implantant respectivement
le tri du nain de jardin, le tri par sélection du maximum et le tri par
insertion, pour réorganiser les éléments du tableau par ordre croissant
(pour le tri du nain et le tri par insertion) ou décroissant (pour le
tri par sélection du maximum). On rappelle que ces tris ont été
présentés lors de la séance 10. <strong>Attention</strong> : si vous
recopier la correction Go des tris (ce qui est tout à fait acceptable
!), n’oubliez pas qu’en Go <code>idx := 1</code> déclare
<code>idx</code> comme un <code>int</code> (signé) et pas un
<code>unsigned</code>, ce qui a son importance pour le tri par
insertion.</p>
<p>Vous compléterez ensuite la fonction <code>main</code> pour tester
vos tris sur des tableaux de tailles comprises entre 0 et TAILLE_MAX
inclus. Pour cela, vous aurez besoin d’allouer vos tableaux avant de les
remplir, et il faut donc parler ici de gestion de la mémoire.</p>
<p>En C, il n’existe pas de ramasse-miettes comme c’était le cas en Go :
la gestion de la mémoire se fait de façon manuelle, et c’est au
programmeur de comprendre ce qu’il fait.</p>
<p>Pour allouer une zone mémoire, on doit utiliser la fonction
<code>malloc</code> (<code>man 3 malloc</code>), qui ressemble un peu à
la fonction <code>new</code> de Go, mais en plus primitif :
<code>malloc</code> prend en paramètre la taille en octets de la zone à
allouer. Par exemple,
<code>int *tab = malloc(TAILLE_MAX * sizeof(int));</code> va nous
permettre d’allouer un tableau de TAILLE_MAX entiers signés, sachant que
chaque entier occupe <code>sizeof(int)</code> octets : l’opérateur
<code>sizeof</code> renvoie le nombre d’octets nécessaire pour stocker
une variable du type de son paramètre.</p>
<p><strong>Attention</strong> : à la différence de Go, les zones
mémoires allouées par <code>malloc</code> ne sont pas initialisées avec
des zéros ! La zone récupérée contient ce que le programme précédent y a
laissé, c’est-à-dire des valeurs quelconques. Si on veut garantir
l’initialisation à zéro, on peut utiliser la fonction
<code>calloc</code> (<code>man 3 calloc</code>) qui fait exactement ça,
mais elle ne nous sera pas utile ici vu qu’on va utiliser
<code>remplir</code> pour initialiser nos tableaux.</p>
<p>Une autre conséquence de l’absence d’un ramasse-miettes est que la
mémoire ne sera jamais désallouée toute seule pendant l’exécution du
programme. Parfois ce n’est pas gênant, car toute la mémoire est libérée
automatiquement lorsque le programme se termine. Mais si on fait des
allocations dans une boucle comme c’est le cas ici, on risque de saturer
l’espace mémoire si on ne libère pas les zones allouées quand on n’en a
plus besoin.</p>
<p>Pour libérer une zone mémoire allouée par <code>malloc</code> (ou
<code>calloc</code>), il suffit d’utiliser la fonction <code>free</code>
(<code>man 3 free</code>) : par exemple, on pourra libérer nos tableaux
avec <code>free(tab);</code>.</p>
<p>Pour recopier un tableau dans un autre (ou plus généralement le
contenu d’une zone mémoire dans une autre), vous pouvez utiliser ici la
fonction <code>memcpy</code> (<code>man 3 memcpy</code>).
<strong>Attention</strong> : il faut que la zone mémoire destination
soit <strong>allouée</strong> (avec <code>malloc</code>) avant
d’utiliser <code>memcpy</code> ! De plus, <code>memcpy</code> prend en
paramètre la taille en octets de la zone à recopier, pas le nombre
d’éléments : il faut donc le multiplier par <code>sizeof</code> de la
taille d’un élément, comme pour <code>malloc</code>.</p>
<p>Une fois les trois fonctions de tri et la fonction principale
implantées, compilez et exécutez votre programme pour vous convaincre
que cela fonctionne, en vérifiant les traces que vous aurez ajoutées à
la fonction <code>main</code>.</p>
<p>Mais lorsqu’on manipule de la mémoire, il n’est pas forcément
suffisant de se baser sur des traces pour être sûrs de notre coup. Il
existe un programme très utile appelé Valgrind, donc le but est
justement de vérifier les accès et de détecter les fuites mémoire dans
un programme. Il peut s’exécuter simplement par la commande
<code>valgrind --leak-check=full ./tris_tabs</code> et pourra produire
un affichage comme ci-dessous si tout se passe bien :</p>
<pre class="text"><code>==3086== Memcheck, a memory error detector
==3086== Copyright (C) 2002-2022, and GNU GPL&#39;d, by Julian Seward et al.
==3086== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==3086== Command: ./tris_tabs
==3086== 
***** Tableau de taille 0 *****
Tableau initial            : [ ]
Tableau trié par le nain   : [ ]
Tableau trié par sélection : [ ]
Tableau trié par insertion : [ ]

***** Tableau de taille 1 *****
Tableau initial            : [ 0 ]
Tableau trié par le nain   : [ 0 ]
Tableau trié par sélection : [ 0 ]
Tableau trié par insertion : [ 0 ]

***** Tableau de taille 2 *****
Tableau initial            : [ 4 5 ]
Tableau trié par le nain   : [ 4 5 ]
Tableau trié par sélection : [ 5 4 ]
Tableau trié par insertion : [ 4 5 ]

***** Tableau de taille 3 *****
Tableau initial            : [ 4 7 9 ]
Tableau trié par le nain   : [ 4 7 9 ]
Tableau trié par sélection : [ 9 7 4 ]
Tableau trié par insertion : [ 4 7 9 ]

***** Tableau de taille 4 *****
Tableau initial            : [ 1 2 9 3 ]
Tableau trié par le nain   : [ 1 2 3 9 ]
Tableau trié par sélection : [ 9 3 2 1 ]
Tableau trié par insertion : [ 1 2 3 9 ]

***** Tableau de taille 5 *****
Tableau initial            : [ 6 3 8 9 6 ]
Tableau trié par le nain   : [ 3 6 6 8 9 ]
Tableau trié par sélection : [ 9 8 6 6 3 ]
Tableau trié par insertion : [ 3 6 6 8 9 ]

***** Tableau de taille 6 *****
Tableau initial            : [ 9 6 0 8 7 9 ]
Tableau trié par le nain   : [ 0 6 7 8 9 9 ]
Tableau trié par sélection : [ 9 9 8 7 6 0 ]
Tableau trié par insertion : [ 0 6 7 8 9 9 ]

==3086== 
==3086== HEAP SUMMARY:
==3086==     in use at exit: 0 bytes in 0 blocks
==3086==   total heap usage: 15 allocs, 15 frees, 1,360 bytes allocated
==3086== 
==3086== All heap blocks were freed -- no leaks are possible
==3086== 
==3086== For lists of detected and suppressed errors, rerun with: -s
==3086== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></pre>
<p>On utilisera plus extensivement Valgrind lors de la séance suivante,
mais vous pouvez déjà commencer à vous familiariser avec ce qu’il
affiche.</p>

</main>
<div><br></div>
</body>
</html>
