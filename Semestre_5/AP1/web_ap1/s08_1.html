<!DOCTYPE html>
<html lang="fr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Algorithmique et Programmation 1</title>
    <link rel="stylesheet" href="./ap1.css">
    <link rel="stylesheet" href="./atom-one-dark.min.css">
    <link rel="stylesheet" href="./atom-one-light.min.css">
    <script src="theme-switcher.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
</head>

<body>
<header>
<a id="theme-switcher" href="#dark" aria-label="Switch to Light Mode" class="contrast">
    <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 19a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z" stroke-width="0" fill="currentColor"></path><path d="M18.313 16.91l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.218 -1.567l.102 .07z" stroke-width="0" fill="currentColor"></path><path d="M7.007 16.993a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z" stroke-width="0" fill="currentColor"></path><path d="M4 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z" stroke-width="0" fill="currentColor"></path><path d="M21 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z" stroke-width="0" fill="currentColor"></path><path d="M6.213 4.81l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.217 -1.567l.102 .07z" stroke-width="0" fill="currentColor"></path><path d="M19.107 4.893a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z" stroke-width="0" fill="currentColor"></path><path d="M12 2a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z" stroke-width="0" fill="currentColor"></path><path d="M12 7a5 5 0 1 1 -4.995 5.217l-.005 -.217l.005 -.217a5 5 0 0 1 4.995 -4.783z" stroke-width="0" fill="currentColor"></path></svg>
</a>
<h1><a href="index.html">Algo-Prog 1</a> : <a href="index.html#Chap2">Chapitre 2</a> : <a href="index.html#Chap2Seance08">Séance 08</a> : <a href="s08_1.html">Bases sur les tableaux statiques</a></h1>
</header>
<main>
<div style="font-size: x-large;">
	&check; Correction : <a href="s08_1.go">s08_1.go</a>
</div>
<h2 id="énoncé">Énoncé</h2>
<h3 id="algorithmes-de-bases-sur-les-tableaux">Algorithmes de bases sur
les tableaux</h3>
<p>On va écrire un programme comprenant des fonctions de base manipulant
des tableaux. Bien sûr, la plupart des langages de programmation
modernes fournissent déjà des fonctions similaires : le but de
l’exercice est de comprendre comment elles fonctionnent et aussi les
coûts induis en les reprogrammant nous même. Dans toutes les fonctions
ci-dessous, vous n’avez donc le droit d’utiliser que la fonction
prédéfinie <code>len</code> (<a
href="https://pkg.go.dev/builtin#len">documentation</a>), ainsi que
toutes les fonctions d’affichage fournies, sauf indication contraire
dans l’énoncé.</p>
<p>Pour simplifier les choses dans cet exercice de base, on va déclarer
deux variables globales :</p>
<ul>
<li>une constante <code>valSup</code> qui fixe la borne supérieure
exclue des éléments du tableau : comme on travaillera sur un tableau
d’entiers, on pourra définir par exemple <code>valSup</code> à 10 pour
remplir le tableau avec des chiffres dans
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mi>.</mi><mn>.9</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0..9]</annotation></semantics></math>
;</li>
<li>un tableau d’entiers <code>tab</code> d’une capacité fixée en dur
(par exemple pour commencer : 12) sur lequel on va travailler.</li>
</ul>
<p>On devra bien sûr tester nos fonctions au fur et à mesure en ajoutant
des tests pertinents dans la fonction <code>main</code>.</p>
<p>Pour tester nos fonctions, on sera amené à faire évoluer la capacité
du tableau (simplement en changeant la constante dans la déclaration du
tableau et en recompilant/re-exécutant le programme) pour tester les
valeurs limites : 12 peut être vue comme le cas général, et 0, 1, 2 et 3
peuvent être des valeurs limites auxquelles on doit penser quand on
écrit les fonctions.</p>
<p><strong>Attention</strong> : on doit bien travailler sur un tableau
défini comme une variable globale, et ne <strong>surtout pas</strong>
essayer de passer un tableau en paramètre des fonctions ci-dessous (on
verra dans les séances suivantes comment faire ça).</p>
<p>Écrire une fonction <code>remplir()</code> qui parcourt le tableau
pour affecter chaque case avec un entier aléatoire dans entre 0 inclus
et <code>valSup</code> exclue : on aura surement besoin de la fonction
<code>rand.Intn</code> (<a
href="https://pkg.go.dev/math/rand#Intn">documentation</a>) qu’on a déjà
vue.</p>
<p>Écrire une fonction <code>afficher()</code> qui affiche le contenu du
tableau par exemple sous le format <code>[ 9 8 2 9 0 0 4 7 8 ]</code>.
<strong>Bien sûr</strong> vous ne devez pas simplement utiliser
<code>Println</code> pour afficher tout le tableau, ça serait trop
simple ! On veut que vous parcouriez le tableau pour afficher chaque
élément un par un.</p>
<p>Écrire une fonction <code>valDansTab(val int) bool</code> qui vérifie
si le tableau contient la valeur passée en paramètre.</p>
<p>Écrire une fonction <code>inverser()</code> qui inverse le contenu du
tableau en procédant par échange d’éléments : par exemple, le tableau
<code>[ 1 2 3 4 ]</code> deviendra <code>[ 4 3 2 1 ]</code>.</p>
<h3 id="implantation-dune-pile-bornée">Implantation d’une pile
bornée</h3>
<p>Une pile est une structure de données classique (<a
href="https://fr.wikipedia.org/wiki/Pile_(informatique)">page
Wikipédia</a>). Une implantation simple de cette structure de données
consiste à utiliser un tableau de capacité constante fixée statiquement
: on parle alors de pile bornée.</p>
<p>Une pile fournie au moins deux primitives classiques :</p>
<ul>
<li><code>empiler(val)</code> sert à ajouter une valeur dans la pile
;</li>
<li><code>dépiler() -&gt; val</code> sert à retirer et renvoyer une
valeur stockée dans la pile.</li>
</ul>
<p>Le principe d’une pile est le « dernier arrivé, premier sorti » :
cela signifie que la primitive <code>dépiler</code> renverra toujours la
valeur insérée dans la pile par le dernier appel à
<code>empiler</code>.</p>
<p>On a donc besoin d’une variable globale appelée « sommet de pile »
qui indique :</p>
<ul>
<li>soit la case contenant la dernière valeur empilée ;</li>
<li>soit la première case libre (donc la case qui suit immédiatement la
dernière case occupée).</li>
</ul>
<p>Les deux conventions sont valables, on choisira ici d’indiquer la
dernière case occupée. <strong>Notez bien</strong> que le sommet de la
pile est l’indice de case contenant la valeur la plus récente (pas la
valeur elle-même).</p>
<p>Ajouter une variable globale <code>sommetPile</code> et l’initialiser
de façon appropriée (si la valeur ne vous parait pas évidente, implantez
d’abord les fonctions ci-dessous). Dans cet exercice, on réutilise le
tableau déjà défini en variable statique dans l’exercice précédent :
vous pouvez changer sa taille pour faire des tests de piles vides et
pleines (par exemple : 5).</p>
<p>Écrire une fonction <code>afficherPile()</code> qui affiche le
contenu <strong>significatif</strong> de la pile, c’est-à-dire sans les
valeurs stockées après le sommet de pile. En effet, il est important de
noter qu’on ne va pas « effacer » (ce qui ne veut rien dire en
informatique : une case mémoire contient toujours une valeur et zéro est
une valeur comme une autre) les cases inoccupées du tableau quand on
retire des valeurs. Pour vous en convaincre, vous pouvez appeler la
fonction <code>afficher</code> pour vérifier que toutes les cases du
tableau contiennent bien des valeurs résiduelles.</p>
<p><strong>Attention</strong> : vous ne devez pas utiliser la syntaxe
que vous avez peut-être vu en Python qui permet d’écrire par exemple
<code>tab[inf:sup]</code> pour récupérer une tranche d’un tableau, car
elle n’est pas aussi simple à utiliser en Go !</p>
<p>Écrire une fonction <code>empiler(val int) error</code> qui ajoute la
valeur à sa place dans la pile et met à jour le somme de pile. Vous
devez bien sûr gérer correctement la possibilité que la pile soit déjà
pleine, en renvoyant une erreur appropriée si c’est le cas, et
<code>nil</code> sinon.</p>
<p>Écrire une fonction <code>depiler() (int, error)</code> qui renvoie
la valeur stockée dans la pile le plus récemment et met à jour le sommet
de pile. Là encore, il faudra renvoyer une erreur si la pile est déjà
vide.</p>
<p>Vous testerez bien sûr ces fonctions, par exemple en programmant une
petite interface permettant à l’utilisateur d’interagir avec la pile,
sur le modèle suivant :</p>
<pre class="text"><code>Pile bornée : entrez les valeur une par une :
- les chiffres dans [0..9] seront empilés
- -1 signifie dépiler une valeur
- toutes les autres valeurs seront ignorées
- ctrl-d pour terminer
(sommet de pile = -1) [ ]
-1
Erreur : la pile est vide !
1
(sommet de pile = 0) [ 1 ]
2
(sommet de pile = 1) [ 1 2 ]
3
(sommet de pile = 2) [ 1 2 3 ]
4
Erreur : la pile est pleine !
-1
-&gt; valeur retirée : 3
(sommet de pile = 1) [ 1 2 ]
-1
-&gt; valeur retirée : 2
(sommet de pile = 0) [ 1 ]
5
(sommet de pile = 1) [ 1 5 ]
6
(sommet de pile = 2) [ 1 5 6 ]</code></pre>
<h3 id="implantation-dune-file-bornée">Implantation d’une file
bornée</h3>
<p>Une file est aussi une structure de données classique (<a
href="https://fr.wikipedia.org/wiki/File_(structure_de_données)">page
Wikipédia</a>). Une implantation simple de cette structure de données
consiste à utiliser un tableau de capacité constante fixée statiquement
: on parle alors de file bornée.</p>
<p>Une file fournie au moins deux primitives classiques :</p>
<ul>
<li><code>inserer(val)</code> sert à ajouter une valeur dans la file
;</li>
<li><code>retirer() -&gt; val</code> sert à retirer et renvoyer une
valeur stockée dans la file.</li>
</ul>
<p>Le principe d’une file est le « premier arrivé, premier sorti »
(<em>First In, First Out</em>) : cela signifie que la primitive
<code>retirer</code> renverra toujours la valeur la plus ancienne
actuellement stockée dans la file.</p>
<p>Si on utilise un tableau pour stocker les valeurs, on ajoutera les
nouvelles valeurs à droite, et on retirera les anciennes à gauche. Par
exemple, si dans le tableau de capacité 3 initialement vide, on ajoute
les valeurs 1 et 2 le tableau contiendra <code>[ 1 2 ? ]</code>, où
<code>?</code> désigne une valeur non significative. Si on appelle
retirer, la valeur renvoyée sera 1 et le tableau contiendra
<code>[? 2 ?]</code>.</p>
<p>On pourrait être tenté de décaler les valeurs vers la gauche du
tableau pour toujours avoir la plus ancienne dans la case d’indice zéro,
mais il serait très inefficace de recopier les valeurs à chaque appel à
<code>retirer</code>. Une méthode très classique pour régler ce problème
consiste à gérer le tableau sous le modèle du « tableau circulaire »,
comme illustré par le schéma ci-dessous.</p>
<style>
    img {background-color: #FFFFFF;}
</style>
<figure>
<img src="s08_1_tabcirc.svg" title="Tableau circulaire"
alt="Tableau circulaire" />
<figcaption aria-hidden="true">Tableau circulaire</figcaption>
</figure>
<p>On voit que l’idée est simple : lorsqu’on ajoute des valeurs à
droite, si on arrive à la fin du tableau, on continue d’insérer les
valeurs dans les cases à gauche qui ont été libérées par des appels
précédents à <code>retirer</code>.</p>
<p>On a donc besoin de deux variables globales :</p>
<ul>
<li><code>ixPlusAncien</code> contient l’indice de la case contenant la
valeur la plus ancienne stockée dans la file ;</li>
<li><code>nbrElem</code> contient le nombre de valeurs significatives
stockées dans le tableau, ce qui permettra de calculer facilement
l’indice de la case contenant la valeur la plus récente, grâce à une
addition et un modulo (opérateur <code>%</code> en Go).</li>
</ul>
<p>Et on réutilise toujours le même tableau défini statiquement dans les
exercices précédent bien sûr.</p>
<p>On recommande d’ailleurs d’implanter une fonction
<code>plusModulo(ix, incr int) int</code> renvoyant la somme de ces deux
paramètres modulo la capacité du tableau, pour factoriser ces opérations
qui seront très fréquentes.</p>
<p>Écrire une fonction <code>afficherFile()</code> qui affiche le
contenu <strong>significatif</strong> de la file, c’est-à-dire sans les
cases notées <code>?</code> dans le schéma ci-dessus. Vous pouvez
appeler la fonction <code>afficher</code> le temps de mettre au point
votre code en affichant le contenu de tout le tableau.</p>
<p>Écrire une fonction <code>inserer(val int) error</code> qui ajoute la
valeur à sa place dans la file et met à jour le nombre d’éléments. Vous
devez bien sûr gérer correctement la possibilité que la file soit déjà
pleine, en renvoyant une erreur appropriée.</p>
<p>Écrire une fonction <code>retirer() (int, error)</code> qui renvoie
la valeur la plus ancienne stockée dans la file et met à jour le nombre
d’éléments ainsi que l’indice de l’élément le plus ancien. Là encore, il
faudra renvoyer une erreur si la file est déjà vide.</p>
<p>Vous pourrez tester vos fonctions avec une interface similaire à
celle développée pour la pile : il devrait d’ailleurs être possible de
factoriser la majorité du code.</p>

</main>
<div><br></div>
</body>
</html>
